/*
    Plugin for computers in vanilla minecraft!
    Copyright (C) 2022  JNNGL

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.jnngl.totalcomputers;

import com.jnngl.totalcomputers.system.TotalOS;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.ItemFrame;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.EquipmentSlot;
import org.bukkit.inventory.ItemStack;
import org.bukkit.map.MapRenderer;
import org.bukkit.map.MapView;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.util.Vector;

import java.util.*;
import java.util.logging.Logger;

/**
 * Base of TotalComputers plugin. (Excuse me for a tons of grammar mistakes :D)
 * @author JNNGL
 */
@SuppressWarnings("unused")
public class TotalComputers extends JavaPlugin implements Listener {

    /* *************** CODE SECTION: RECORDS, ENUMS *************** */
    // Contains useful records and enums.

    /**
     * Describes physical data of computer
     */
    public static record SelectionArea(Location firstPos, Location secondPos, TotalComputers.SelectionArea.Axis axis,
                                TotalComputers.SelectionArea.Direction direction, int width, int height, int area) {

        /**
         * Describes direction of surface normal; UP = UP; DOWN = DOWN; RIGHT = EAST; LEFT = WEST; FORWARD = SOUTH; BACKWARD = NORTH;
         */
        public enum Direction {
            /**
             * Up direction
             */
            UP,

            /**
             * Down direction
             */
            DOWN,

            /**
             * Right direction
             */
            RIGHT,

            /**
             * Left direction
             */
            LEFT,

            /**
             * Forward direction
             */
            FORWARD,

            /**
             * Backward direction
             */
            BACKWARD

        }

        /**
         * Describes axis of surface normal
         */
        public enum Axis {
            /**
             * X axis
             */
            X,

            /**
             * Y axis
             */
            Y,

            /**
             * Z axis
             */
            Z
        }

        /**
         * Default equals generated by IntelliJ IDEA
         * @param o Object to compare
         * @return Equals or not
         */
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            SelectionArea that = (SelectionArea) o;

            if (width != that.width) return false;
            if (height != that.height) return false;
            if (area != that.area) return false;
            if (!firstPos.equals(that.firstPos)) return false;
            if (!secondPos.equals(that.secondPos)) return false;
            if (axis != that.axis) return false;
            return direction == that.direction;
        }

        /**
         * Default hashCode generated by IntelliJ IDEA
         * @return Hash code
         */
        @Override
        public int hashCode() {
            int result = firstPos.hashCode();
            result = 31 * result + secondPos.hashCode();
            result = 31 * result + axis.hashCode();
            result = 31 * result + direction.hashCode();
            result = 31 * result + width;
            result = 31 * result + height;
            result = 31 * result + area;
            return result;
        }
    }

    /**
     * Information about monitor frame with map
     */
    public static record MonitorPiece(MapView mapView, ItemFrame frame) {}

    /**
     * Information about part of the computer
     */
    public static record MonitorPieceIndex(String name, int index) {}

    /**
     * Information about input
     */
    public static record InputInfo(MonitorPieceIndex index, int x, int y, InteractType interactType, Player player) {

        /**
         * Type of interaction with the computer
         */
        public enum InteractType {
            /**
             * Left click action
             */
            LEFT_CLICK,

            /**
             * Right click action
             */
            RIGHT_CLICK
        }

    }

    /* *************** CODE SECTION: FIELDS *************** */

    private final static String replyPrefix = ChatColor.GOLD + "[TotalComputers] " + ChatColor.RESET;
    private Logger logger;
    private ConfigManager configManager;
    private FileConfiguration config, computers;
    private Map<String, List<MonitorPiece>> monitors;
    private Map<ItemFrame, MonitorPieceIndex> interactiveTiles;
    /** Unhandled touch inputs */ public List<InputInfo> unhandledInputs;
    private Map<Player, Location> firstPoses, secondPoses;
    private Map<Player, SelectionArea> areas;
    private List<String> registeredComputers;
    private Map<String, SelectionArea> computersPhysicalData;

    /* *************** CODE SECTION: INITIALIZATION *************** */

    /**
     * Initializes config field
     */
    private void loadConfigs() {
        if(configManager == null) return;
        config = configManager.getFileConfig("config.yml");
        computers = configManager.getFileConfig("computers.yml");
    }

    /**
     * Creates monitor piece
     * @param name Name of the computer
     * @param area Physical data of the computer
     * @param x1 World X
     * @param y1 World Y
     * @param z1 World Z
     * @param displacement Displacement
     * @param monitorPieces Monitor
     * @param i Index of the piece
     */
    private void proceedMonitorPiece(TotalOS os, String name, SelectionArea area, int x1, int y1, int z1, Vector displacement, List<MonitorPiece> monitorPieces, int[] i) {
        Location loc = new Location(area.firstPos.getWorld(), x1, y1, z1).add(displacement);

        final MapView map = Bukkit.createMap(loc.getWorld());

        @SuppressWarnings("deprecation")
        ItemStack is = new ItemStack(Material.MAP, 1, map.getId()); // Information: Use of deprecated API

        for(MapRenderer renderer : map.getRenderers())
            map.removeRenderer(renderer);
        map.addRenderer(new TotalOS.Renderer(name, i[0], this, os, area));

        ItemFrame f = null;
        try {
            for(Entity entity : loc.getWorld().getEntitiesByClasses(ItemFrame.class)) {
                if(entity.getLocation().getBlockX() == loc.getBlockX() && entity.getLocation().getBlockY() == loc.getBlockY() && entity.getLocation().getBlockZ() == loc.getBlockZ()) {
                    f = (ItemFrame) entity;
                    break;
                }
            }
            if(f == null)
                f = area.firstPos.getWorld().spawn(loc, ItemFrame.class);
        } catch (Exception ignored) {}

        if(f != null) {
            f.setItem(is);
            interactiveTiles.put(f, new MonitorPieceIndex(name, i[0]));
            monitorPieces.add(new MonitorPiece(map, f));
        } else logger.info("Failed to init computer: Unable to create or load item frame.");

        i[0]++;
    }

    /**
     * Initializes the computer
     * @param name Name of the computer to initialize
     */
    private void initComputer(String name) {
        final SelectionArea area = computersPhysicalData.get(name);

        Vector displacement;

        int topRightX = Math.max(area.firstPos.getBlockX(), area.secondPos.getBlockX()),
                topRightY = Math.max(area.firstPos.getBlockY(), area.secondPos.getBlockY()),
                topRightZ = Math.max(area.firstPos.getBlockZ(), area.secondPos.getBlockZ()),
                downLeftX = Math.min(area.firstPos.getBlockX(), area.secondPos.getBlockX()),
                downLeftY = Math.min(area.firstPos.getBlockY(), area.secondPos.getBlockY()),
                downLeftZ = Math.min(area.firstPos.getBlockZ(), area.secondPos.getBlockZ());

        if(area.direction == SelectionArea.Direction.RIGHT) displacement = new Vector(1, 0, 0);
        else if(area.direction == SelectionArea.Direction.LEFT) displacement = new Vector(-1, 0, 0);
        else if(area.direction == SelectionArea.Direction.FORWARD) displacement = new Vector(0, 0, 1);
        else if(area.direction == SelectionArea.Direction.BACKWARD) displacement = new Vector(0, 0, -1);
        else displacement = new Vector();

        final int[] i = {0};

        List<MonitorPiece> monitorPieces = new ArrayList<>();

        boolean invert = area.direction == SelectionArea.Direction.BACKWARD || area.direction == SelectionArea.Direction.RIGHT;

        TotalOS os = new TotalOS(area.width*128, area.height*128, name);

        for(int y1 = topRightY; y1 >= downLeftY; y1--) {
            if(invert) {
                for (int x1 = topRightX; x1 >= downLeftX; x1--) {
                    for (int z1 = topRightZ; z1 >= downLeftZ; z1--) {
                        proceedMonitorPiece(os, name, area, x1, y1, z1, displacement, monitorPieces, i);
                    }
                }
            } else {
                for (int x1 = downLeftX; x1 <= topRightX; x1++) {
                    for (int z1 = downLeftZ; z1 <= topRightZ; z1++) {
                        proceedMonitorPiece(os, name, area, x1, y1, z1, displacement, monitorPieces, i);
                    }
                }
            }
        }

        monitors.remove(name);
        monitors.put(name, monitorPieces);
    }

    /**
     * Loads all computers from config
     */
    private void loadComputers() {
        unhandledInputs = new ArrayList<>();
        monitors = new HashMap<>();
        if(computers.isSet("computers.names")) registeredComputers = computers.getStringList("computers.names");
        else registeredComputers = new ArrayList<>();
        computersPhysicalData = new HashMap<>();
        interactiveTiles = new HashMap<>();
        for(String name : registeredComputers) {
            World world = getServer().getWorld(computers.getString("computers."+name+".world"));
            computersPhysicalData.put(name, new SelectionArea(
                    new Location(
                            world, computers.getInt("computers."+name+".area.firstPos.x"),
                            computers.getInt("computers."+name+".area.firstPos.y"),
                            computers.getInt("computers."+name+".area.firstPos.z")
                    ),
                    new Location(
                            world, computers.getInt("computers."+name+".area.secondPos.x"),
                            computers.getInt("computers."+name+".area.secondPos.y"),
                            computers.getInt("computers."+name+".area.secondPos.z")
                    ),
                    SelectionArea.Axis.valueOf(computers.getString("computers."+name+".area.axis")),
                    SelectionArea.Direction.valueOf(computers.getString("computers."+name+".area.direction")),
                    computers.getInt("computers."+name+".area.width"),
                    computers.getInt("computers."+name+".area.height"),
                    computers.getInt("computers."+name+".area.area")
            ));

            initComputer(name);
        }
    }

    /**
     * Initializes logger, config manager, computers etc.
     */
    @Override
    public void onEnable() {
        logger = getLogger();
        configManager = new ConfigManager(this);
        configManager.loadConfigFiles(new ConfigManager.ConfigPath("config.yml", null, "config.yml"), new ConfigManager.ConfigPath("computers.yml", null, "computers.yml"));
        loadConfigs();
        if(!config.isSet("firstRun")) {
            config.set("selection", true);
            config.set("firstRun", false);
        }
        configManager.saveAllConfigs(true);
        loadComputers();
        getServer().getPluginManager().registerEvents(this, this);
        firstPoses = new HashMap<>();
        secondPoses = new HashMap<>();
        areas = new HashMap<>();
        logger.info("Total Computers enabled. (Made by JNNGL)");
    }

    /* *************** CODE SECTION: COMMANDS AND AUTOCOMPLETION *************** */

    /**
     * Processing of command. Permission: <code>totalcomputers.command.totalcomputers</code>
     * @param sender Command executor
     * @param command Command
     * @param label Command label
     * @param args Command Arguments
     * @return Always true
     */
    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if(sender instanceof Player) {
            if(command.getName().equalsIgnoreCase("totalcomputers")) {
                if(!sender.hasPermission("totalcomputers.command.totalcomputers")) { // Check permissions
                    sender.sendMessage(replyPrefix + ChatColor.RED + "You don't have enough permissions.");
                    return true;
                }
                if(args.length == 0 || args[0].equalsIgnoreCase("help")) { // Help subcommand
                    sender.sendMessage(replyPrefix + "Help [1/1]");
                    sender.sendMessage(ChatColor.GOLD + "Aliases: " + ChatColor.WHITE  + " /tcomputers, /tcmp");
                    sender.sendMessage(ChatColor.GOLD + "/totalcomputers help" + ChatColor.WHITE + " - show help menu.");
                    sender.sendMessage(ChatColor.GOLD + "/totalcomputers create <name>" + ChatColor.WHITE + " - creates new computer at area of wall selected with diamond hoe. (See also /totalcomputers selection)");
                    sender.sendMessage(ChatColor.GOLD + "/totalcomputers remove <name>" + ChatColor.WHITE + " - removes computer.");
                    sender.sendMessage(ChatColor.GOLD + "/totalcomputers list" + ChatColor.WHITE + " - prints list of created computers.");
                    sender.sendMessage(ChatColor.GOLD + "/totalcomputers data <name>" + ChatColor.WHITE + " - prints information about computer.");
                    sender.sendMessage(ChatColor.GOLD + "/totalcomputers selection <enable|disable|toggle|state>" + ChatColor.WHITE + " - enables/disables/toggles/prints possibility of wall area selection with diamond hoe.");
                    sender.sendMessage(ChatColor.GOLD + "/totalcomputers reload" + ChatColor.WHITE + " - reloads all configuration files.");
                }
                else if(args[0].equalsIgnoreCase("reload")) { // Reload subcommand
                    boolean success = configManager.reloadAllConfigs();
                    loadConfigs();
                    if(success) {
                        loadComputers();
                        sender.sendMessage(replyPrefix + ChatColor.GREEN + "Configuration files has been successfully reloaded.");
                    }
                    else sender.sendMessage(replyPrefix + ChatColor.RED   + "Something went wrong!");
                }
                else if(args[0].equalsIgnoreCase("selection")) { // Selection subcommand
                    if(args.length >= 2) {
                        if(args[1].equalsIgnoreCase("enable")) {
                            config.set("selection", true);
                            sender.sendMessage(replyPrefix + "Selection using diamond hoe successfully enabled.");
                            configManager.saveConfig("config.yml");
                        }
                        else if(args[1].equalsIgnoreCase("disable")) {
                            config.set("selection", false);
                            sender.sendMessage(replyPrefix + "Selection using diamond hoe successfully disabled.");
                            configManager.saveConfig("config.yml");
                        }
                        else if(args[1].equalsIgnoreCase("toggle")) {
                            boolean currentState;
                            config.set("selection", (currentState = !isSelectionEnabled()));
                            sender.sendMessage(replyPrefix + "Selection using diamond hoe successfully " + (currentState? "enabled" : "disabled") + '.');
                            configManager.saveConfig("config.yml");
                        }
                        else if(args[1].equalsIgnoreCase("state")) {
                            sender.sendMessage(replyPrefix + "Selection using diamond hoe is currently " + (config.getBoolean("selection")? "enabled" : "disabled") + '.');
                        }
                        else invalidUsage(sender);
                    } else invalidUsage(sender);
                }
                else if(args[0].equalsIgnoreCase("create")) { // Create subcommand
                    if(args.length == 2) {
                        Player player = (Player)sender;
                        if(!areas.containsKey(player)) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "You have not selected area or it is invalid. Select it with diamond hoe. Make sure area selection is enabled.");
                            return true;
                        }
                        SelectionArea area = areas.get(player);
                        if((float)area.width / (float)area.height < 4f/3f) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "Aspect ratio should be at least 4:3");
                            return true;
                        }
                        if(area.width > 16) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "Maximum width in blocks is 16.");
                            return true;
                        }
                        if(area.height > 9) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "Maximum height in blocks is 9.");
                            return true;
                        }
                        if(area.width < 4) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "Minimum width in blocks is 4.");
                            return true;
                        }
                        if(area.height < 3) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "Minimum height in blocks is 3.");
                            return true;
                        }
                        if(area.axis == SelectionArea.Axis.Y) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "Computer cannot be placed on horizontal surface.");
                            return true;
                        }
                        if(registeredComputers.contains(args[1])) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "Computer with this name already exists.");
                            return true;
                        }

                        computers.set("computers."+args[1]+".area.firstPos.x", area.firstPos.getBlockX());
                        computers.set("computers."+args[1]+".area.firstPos.y", area.firstPos.getBlockY());
                        computers.set("computers."+args[1]+".area.firstPos.z", area.firstPos.getBlockZ());
                        computers.set("computers."+args[1]+".area.secondPos.x", area.secondPos.getBlockX());
                        computers.set("computers."+args[1]+".area.secondPos.y", area.secondPos.getBlockY());
                        computers.set("computers."+args[1]+".area.secondPos.z", area.secondPos.getBlockZ());
                        computers.set("computers."+args[1]+".area.direction", area.direction.toString());
                        computers.set("computers."+args[1]+".area.axis", area.axis.toString());
                        computers.set("computers."+args[1]+".area.width", area.width);
                        computers.set("computers."+args[1]+".area.height", area.height);
                        computers.set("computers."+args[1]+".area.area", area.area);
                        computers.set("computers."+args[1]+".world", area.firstPos.getWorld().getName());
                        registeredComputers.add(args[1]);
                        computersPhysicalData.put(args[1], area);
                        computers.set("computers.names", registeredComputers);
                        configManager.saveConfig("computers.yml", true);
                        initComputer(args[1]);
                        sender.sendMessage(replyPrefix + ChatColor.GREEN + "Computer with name '"+args[1]+"' successfully created!");
                    } else if(args.length > 2) {
                        sender.sendMessage(replyPrefix + ChatColor.RED + "Computer name cannot contain spaces!");
                    } else invalidUsage(sender);
                }
                else if(args[0].equalsIgnoreCase("remove")) { // Remove subcommand
                    if(args.length == 2) {
                        if(!registeredComputers.contains(args[1])) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "There is no such computer with name '"+args[1]+"'.");
                            return true;
                        }
                        removeComputer(args[1]);
                        computers.set("computers."+args[1], null);
                        computers.set("computers.names", registeredComputers);
                        configManager.saveConfig("computers.yml", true);
                        sender.sendMessage(replyPrefix + ChatColor.GREEN + "Computer with name '"+args[1]+"' successfully removed!");
                    } else if(args.length > 2) {
                        sender.sendMessage(replyPrefix + ChatColor.RED + "Computer name cannot contain spaces!");
                    } else invalidUsage(sender);
                }
                else if(args[0].equalsIgnoreCase("list")) { // List subcommand
                    if(registeredComputers.isEmpty()) {
                        sender.sendMessage(replyPrefix + ChatColor.GREEN + "None.");
                        return true;
                    }
                    StringBuilder list = new StringBuilder();
                    for(String name : registeredComputers) list.append(name).append(", ");
                    list.delete(list.length()-2, list.length()-1);
                    sender.sendMessage(replyPrefix + ChatColor.GREEN + "Available computers: " + ChatColor.RESET + list);
                }
                else if(args[0].equalsIgnoreCase("data")) { // Data subcommand
                    if(args.length == 2) {
                        if(!registeredComputers.contains(args[1])) {
                            sender.sendMessage(replyPrefix + ChatColor.RED + "There is no such computer with name '"+args[1]+"'.");
                            return true;
                        }
                        SelectionArea area = computersPhysicalData.get(args[1]);
                        sender.sendMessage(replyPrefix + "Information:");
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "Name: " + ChatColor.RESET + args[1]);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "First Corner Position: " + ChatColor.RESET);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "   X: " + ChatColor.RESET + area.firstPos.getBlockX());
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "   Y: " + ChatColor.RESET + area.firstPos.getBlockY());
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "   Z: " + ChatColor.RESET + area.firstPos.getBlockZ());
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "Second Corner Position: " + ChatColor.RESET);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "   X: " + ChatColor.RESET + area.secondPos.getBlockX());
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "   Y: " + ChatColor.RESET + area.secondPos.getBlockY());
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "   Z: " + ChatColor.RESET + area.secondPos.getBlockZ());
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "Axis: " + ChatColor.RESET + area.axis);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "Facing Direction: " + ChatColor.RESET + area.direction);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "Width: " + ChatColor.RESET + area.width);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "Height: " + ChatColor.RESET + area.height);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "Area: " + ChatColor.RESET + area.area);
                        sender.sendMessage(replyPrefix + ChatColor.GOLD + "World: " + ChatColor.RESET + area.firstPos.getWorld().getName());
                    } else if(args.length > 2) {
                        sender.sendMessage(replyPrefix + ChatColor.RED + "Computer name cannot contain spaces!");
                    } else invalidUsage(sender);
                }
            }
        } else sender.sendMessage(replyPrefix + ChatColor.RED + "Only players can be execute this command.");
        return true;
    }

    /**
     * Tab autocompletion of command. Permission: <code>totalcomputers.command.totalcomputers</code>
     * @param sender Command sender
     * @param command Command
     * @param alias Alias
     * @param args Command Arguments
     * @return List of autocompletes
     */
    @Override
    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
        List<String> variants = new ArrayList<>();
        if(!sender.hasPermission("totalcomputers.command.totalcomputers")) return variants;
        String[] all = {};
        if(command.getName().equalsIgnoreCase("totalcomputers")) {
            if(args.length == 1) all = new String[] { "help", "create", "remove", "selection", "list", "reload", "data" };
            else if(args[0].equalsIgnoreCase("selection")) {
                if(args.length == 2) {
                    all = new String[] { "enable", "disable", "toggle", "state" };
                }
            }
            else if(args[0].equalsIgnoreCase("remove") || args[0].equalsIgnoreCase("data")) {
                all = new String[registeredComputers.size()];
                registeredComputers.toArray(all);
            }
        }
        for(String str : all) {
            if(str.startsWith(args[args.length-1])) variants.add(str);
        }
        if(variants.isEmpty()) return null;
        return variants;
    }

    /* *************** CODE SECTION: EVENTS *************** */

    /**
     * Processes selection with diamond hoe. Permission:  <code>totalcomputers.selection</code>
     * @param event Event (PlayerInteractEvent)
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void selectionEvent(PlayerInteractEvent event) {
        if(event.getHand() != EquipmentSlot.HAND) return;
        if(!isSelectionEnabled()) return;
        Player player = event.getPlayer();
        if(!player.hasPermission("totalcomputers.selection")) return;
        if(player.getInventory().getItemInMainHand() != null && !player.getInventory().getItemInMainHand().equals(new ItemStack(Material.DIAMOND_HOE))) return;
        Action action = event.getAction();
        Location loc, oldLoc = null;
        boolean displayArea = false;
        if(action.equals(Action.LEFT_CLICK_BLOCK)) {
            if(firstPoses.containsKey(player)) oldLoc = firstPoses.get(player);
            firstPoses.remove(player);
            firstPoses.put(player, loc = event.getClickedBlock().getLocation());
            event.setCancelled(true);
            if(oldLoc == null || !oldLoc.equals(loc)) {
                player.sendMessage(replyPrefix + ChatColor.LIGHT_PURPLE + "First position is set. (X: "+loc.getBlockX()+", Y: "+loc.getBlockY()+", Z: "+loc.getBlockZ()+")");
            }
            if(secondPoses.containsKey(player)) computeArea(player);
        } else if(action.equals(Action.RIGHT_CLICK_BLOCK)) {
            if(secondPoses.containsKey(player)) oldLoc = secondPoses.get(player);
            secondPoses.remove(player);
            secondPoses.put(player, loc = event.getClickedBlock().getLocation());
            event.setCancelled(true);
            if(oldLoc == null || !oldLoc.equals(loc)) {
                player.sendMessage(replyPrefix + ChatColor.LIGHT_PURPLE + "Second position is set. (X: "+loc.getBlockX()+", Y: "+loc.getBlockY()+", Z: "+loc.getBlockZ()+")");
            }
            if(firstPoses.containsKey(player)) computeArea(player);
        }
    }

    /**
     * Clean up when player quits the server
     * @param event Event (PlayerQuitEvent)
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void playerLeave(PlayerQuitEvent event) {
        Player player = event.getPlayer();
        firstPoses.remove(player);
        secondPoses.remove(player);
        areas.remove(player);
    }

    /**
     * Protection and input handling
     * @param event Event (EntityDamageByEntityEvent)
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void onHit(EntityDamageByEntityEvent event) {
        if(event.getEntity().getType() == EntityType.ITEM_FRAME) {
            if(interactiveTiles.containsKey(((ItemFrame) event.getEntity()))) {
                if(event.getDamager() instanceof Player)
                    processInput((Player) event.getDamager(), InputInfo.InteractType.LEFT_CLICK);
                event.setCancelled(true);
            }
        }
    }

    /**
     * Protection and input handling
     * @param event Event (PlayerInteractEntityEvent)
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void onInteract(PlayerInteractEntityEvent event) {
        if(event.getRightClicked().getType() == EntityType.ITEM_FRAME) {
            if(interactiveTiles.containsKey(((ItemFrame) event.getRightClicked()))) {
                processInput(event.getPlayer(), InputInfo.InteractType.RIGHT_CLICK);
                event.setCancelled(true);
            }
        }
    }

    /**
     * Protection and input handling
     * @param event Event (PlayerInteractEvent)
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void mapInteract(PlayerInteractEvent event) {
        if(event.getHand() != EquipmentSlot.HAND) return;
        InputInfo.InteractType interactType;
        if(event.getAction() == Action.LEFT_CLICK_BLOCK || event.getAction() == Action.LEFT_CLICK_AIR) interactType = InputInfo.InteractType.LEFT_CLICK;
        else if(event.getAction() == Action.RIGHT_CLICK_BLOCK || event.getAction() == Action.RIGHT_CLICK_BLOCK) interactType = InputInfo.InteractType.RIGHT_CLICK;
        else return;
        if(processInput(event.getPlayer(), interactType)) event.setCancelled(true);
    }

    /**
     * Clean up on plugin disable
     */
    @Override
    public void onDisable() {
        String[] computers = new String[registeredComputers.size()];
        registeredComputers.toArray(computers);
        for(String computer : computers)
            removeComputer(computer);
        logger.info("Total Computers disabled.");
    }

    /* *************** CODE SECTION: HELPERS *************** */

    /**
     * Removes the computer
     * @param name Name of computer to remove
     */
    private void removeComputer(String name) {
        boolean renderThreadFinished = false;
        List<MonitorPiece> monitor = monitors.get(name);
        for(MonitorPiece piece : monitor) {
            final MapView map = piece.mapView;
            final ItemFrame frame = piece.frame;
            for(MapRenderer renderer : map.getRenderers()) {
                map.removeRenderer(renderer);
                if(renderer instanceof TotalOS.Renderer r) {
                    if(!renderThreadFinished) {
                        r.getSystem().turnOff();
                        renderThreadFinished = true;
                    }
                }
            }

            interactiveTiles.remove(frame);
            frame.remove();
        }
        List<InputInfo> toRemove = new ArrayList<>();
        for(InputInfo inputInfo : unhandledInputs) {
            if(inputInfo.index.name.equals(name))
                toRemove.add(inputInfo);
        }
        unhandledInputs.removeAll(toRemove);
        registeredComputers.remove(name);
        computersPhysicalData.remove(name);
        monitors.remove(name);
        if(!renderThreadFinished) System.err.println("Failed to finish render loop.");
    }

    /**
     * Process the input
     * @param entity Player
     * @param interactType Type of interaction
     * @return Whether the input was handled
     */
    private boolean processInput(Player entity, InputInfo.InteractType interactType) {
        Block block = entity.getTargetBlock(null, 100);
        Location blockLoc = block.getLocation();
        AABB aabb = new AABB(blockLoc.toVector().add(new Vector(0.5D, 0.5D, 0.5D)), -0.5625D, 0.5625D, -0.5625D, 0.5625D, -0.5625D, 0.5625D);
        Vector intersection = aabb.getIntersection(entity.getEyeLocation().toVector(), entity.getEyeLocation().toVector().add(entity.getLocation().getDirection().multiply(10)));
        if(intersection != null) {

            for(ItemFrame tile : interactiveTiles.keySet()) {

                Vector displacement = null;
                if(tile.getFacing() == BlockFace.SOUTH) displacement = new Vector(0, 0, 1);
                else if(tile.getFacing() == BlockFace.NORTH) displacement = new Vector(0, 0, -1);
                else if(tile.getFacing() == BlockFace.WEST) displacement = new Vector(-1, 0, 0);
                else if(tile.getFacing() == BlockFace.EAST) displacement = new Vector(1, 0, 0);
                if(displacement != null) {
                    Location expLoc = blockLoc.clone().add(displacement);
                    Location tileLoc = tile.getLocation();
                    if(expLoc.getWorld().getName().equals(tileLoc.getWorld().getName())
                            && expLoc.getBlockX() == tileLoc.getBlockX()
                            && expLoc.getBlockY() == tileLoc.getBlockY()
                            && expLoc.getBlockZ() == tileLoc.getBlockZ()) {
                        double u = 0, v = 0;
                        if(tile.getFacing() == BlockFace.SOUTH) {
                            u = intersection.getX() - expLoc.getBlockX();
                            v = 1.f - (intersection.getY() - expLoc.getBlockY());
                        }
                        else if(tile.getFacing() == BlockFace.NORTH) {
                            u = 1.f - (intersection.getX() - expLoc.getBlockX());
                            v = 1.f - (intersection.getY() - expLoc.getBlockY());
                        }
                        else if(tile.getFacing() == BlockFace.WEST) {
                            u = intersection.getZ() - expLoc.getBlockZ();
                            v = 1.f - (intersection.getY() - expLoc.getBlockY());
                        }
                        else if(tile.getFacing() == BlockFace.EAST) {
                            u = 1.f - (intersection.getZ() - expLoc.getBlockZ());
                            v = 1.f - (intersection.getY() - expLoc.getBlockY());
                        }
                        int subX = (int)(u*128);
                        int subY = (int)(v*128);
                        boolean hasPerm = entity.hasPermission("totalcomputers.use");
                        boolean nHoldItem = entity.getInventory().getItemInMainHand().getType() == Material.AIR;
                        if(hasPerm && nHoldItem) {
                            unhandledInputs.add(new InputInfo(interactiveTiles.get(tile), subX, subY, interactType, entity));
                        } else if(!hasPerm) {
                            entity.sendMessage(replyPrefix + ChatColor.GRAY + "You don't have enough permissions!");
                        } else {
                            entity.sendMessage(replyPrefix + ChatColor.GRAY + "You are trying to use the computer with an item in main hand!");
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Prints message about invalid usage of command
     * @param sender Command executor
     */
    private void invalidUsage(CommandSender sender) {
        sender.sendMessage(replyPrefix + ChatColor.RED + "Invalid usage! Use '/totalcomputers help' for information about commands.");
    }

    /**
     * @return Whether the selection is enabled
     */
    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private boolean isSelectionEnabled() {
        return config.getBoolean("selection");
    }

    /**
     * Calculates information about selection: axis, direction, width, height etc. (See record SelectionArea)
     * @param player Player
     */
    private void computeArea(Player player) {
        SelectionArea.Axis axis;
        SelectionArea.Direction direction;
        Location first = firstPoses.get(player);
        Location second = secondPoses.get(player);
        if(!first.getWorld().getName().equals(second.getWorld().getName())) {
            player.sendMessage(replyPrefix + ChatColor.RED + "Positions are located in different worlds!");
            return;
        }
        if (first.getBlockX() == second.getBlockX()) axis = SelectionArea.Axis.X;
        else if (first.getBlockY() == second.getBlockY()) axis = SelectionArea.Axis.Y;
        else if (first.getBlockZ() == second.getBlockZ()) axis = SelectionArea.Axis.Z;
        else {
            player.sendMessage(replyPrefix + ChatColor.RED + "Selected area should be flat!");
            return;
        }

        Location loc = player.getLocation();

        int width, height;

        if(axis == SelectionArea.Axis.X) {
            double x = loc.getX();
            direction = (x < first.getBlockX())? SelectionArea.Direction.LEFT : SelectionArea.Direction.RIGHT;
            width = Math.abs(first.getBlockZ() - second.getBlockZ())+1;
            height = Math.abs(first.getBlockY() - second.getBlockY())+1;
        } else if(axis == SelectionArea.Axis.Y) {
            double y = loc.getY();
            direction = (y < first.getBlockY())? SelectionArea.Direction.DOWN : SelectionArea.Direction.UP;
            width = Math.abs(first.getBlockX() - second.getBlockX())+1;
            height = Math.abs(first.getBlockZ() - second.getBlockZ())+1;
        } else {
            double z = loc.getZ();
            direction = (z < first.getBlockZ())? SelectionArea.Direction.BACKWARD : SelectionArea.Direction.FORWARD;
            width = Math.abs(first.getBlockX() - second.getBlockX())+1;
            height = Math.abs(first.getBlockY() - second.getBlockY())+1;
        }

        int area = width * height;
        areas.remove(player);
        if(area == 1) {
            player.sendMessage(replyPrefix + ChatColor.RED + "Selected area cannot be 1*1.");
            return;
        }
        areas.put(player, new SelectionArea(first, second, axis, direction, width, height, area));
        player.sendMessage(replyPrefix + ChatColor.LIGHT_PURPLE + "Selected Area: [Direction: "+direction+", Area: "+area+" ("+width+"*"+height+")]");
    }

}
